#!/usr/bin/env bash
#
# Require bash version >= 4.4
#
# This script depends on passwordless ssh and passwordless sudo via the current
# user ($USER) on remote hosts.

set -euo pipefail

readonly SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
# shellcheck source=./common.sh
. "$SCRIPT_DIR/common.sh"


usage() {
  cat <<EOF
Usage: $0 -m MON_IP -o <HOST_OSD_DEVICE> [-o <HOST_OSD_DEVICE> ...]
  -m : (\$MON_IP)             IP address for the clusterâ€™s first monitor daemon
  -o : (\$HOST_OSD_DEVICES)   Create an OSD on the storage device of the host defined by:
                               HOST_OSD_DEVICE := host:device1[,device2,...]
                             The device can only be a LVM logical volume or a raw block device.
  -h :                       Show this help text

All SSH connections to host clusters will use the user defined by '\$USER' (current: $USER).

EOF
}

HOST_OSD_DEVICES=()
while getopts ":m:o:h" option; do
  case $option in
    m ) readonly MON_IP=$OPTARG ;;
    o ) HOST_OSD_DEVICES+=("$OPTARG") ;;
    h )
      usage
      exit
      ;;
    \? )
      usage
      common::err $(( ERR_STATUS_START + 1 )) "Invalid option: -$OPTARG"
      ;;
    :  )
      usage
      common::err $(( ERR_STATUS_START + 1 )) "Option -$OPTARG requires an argument."
      ;;
    *  )
      usage
      exit
  esac
done
shift "$(( OPTIND - 1 ))"

if [[ -z "${MON_IP:-}" ]]; then
  usage
  common::err $(( ERR_STATUS_START + 2 )) "Please specify the IP address of the first monitor"
fi

if ! [[ "$MON_IP" =~ ^[[:digit:].]+$ ]]; then
  common::err $(( ERR_STATUS_START + 3 )) "Invalid IP address: $MON_IP"
fi

if (( "${#HOST_OSD_DEVICES[@]}" == 0 )); then
  usage
  common::err $(( ERR_STATUS_START + 2 )) "Please specify HOST_OSD_DEVICEs for OSDs"
fi

parse_osd_devices() {
  local -n device_arr=$1
  # shellcheck disable=SC2034
  IFS=',' read -ra device_arr <<< "$2"
}

index_of_arr() {
  local -nr arr=$1
  local -r lookfor="$2"
  local -i idx found_idx=-1
  for idx in "${!arr[@]}"; do
    if [[ "${arr[idx]}" == "$lookfor" ]]; then
      found_idx="$idx"
      break
    fi
  done
  echo "$found_idx"
}

OSD_HOSTS=()
OSD_DEVICES=()
populate_osd_host_devices() {
  local host_devices_str
  for host_devices_str in "${HOST_OSD_DEVICES[@]}"; do
    local -a host_devices_arr
    IFS=':' read -ra host_devices_arr <<< "$host_devices_str"
    if (( ${#host_devices_arr[@]} != 2 )); then
      common::err $(( ERR_STATUS_START + 3 )) "Invalid HOST_OSD_DEVICE (host:device1[,device2,...]) format: $host_devices_str"
    fi
    if [[ "${host_devices_arr[0]}" == *@* ]]; then
      common::err $(( ERR_STATUS_START + 3 )) "All SSH connections use the user defined by '\$USER' (current: $USER)"
    fi

    local -i index_of_hosts
    index_of_hosts=$(index_of_arr OSD_HOSTS "${host_devices_arr[0]}")

    # shellcheck disable=SC2034
    local -a devices prev_devices
    local -i index_of_devices
    parse_osd_devices devices "${host_devices_arr[1]}"
    for device in "${devices[@]}"; do
      if ! [[ "$device" =~ ^/dev/ ]]; then
        common::err $(( ERR_STATUS_START + 3 )) "Invalid device '$device' in '$host_devices_str'"
      fi

      if (( index_of_hosts >= 0 )); then
        parse_osd_devices prev_devices "${OSD_DEVICES[index_of_hosts]}"
        index_of_devices=$(index_of_arr prev_devices "$device")
        if (( index_of_devices >= 0 )); then
          common::err $(( ERR_STATUS_START + 3 )) "Duplicated device '$device' specified for host '${host_devices_arr[0]}'"
        fi
      fi
    done

    OSD_HOSTS+=("${host_devices_arr[0]}")
    OSD_DEVICES+=("${host_devices_arr[1]}")
  done
}
populate_osd_host_devices

stage() { printf "\\n\\n\\033[1;33m[STAGE] %s\\033[0m\\n" "$*"; }

verify_parameters() {
  local -i exit_status=0

  common::info "> Check the host for the monitor"
  trace_on
  ssh "${SSH_COMM_OPTIONS[@]}" "$USER@$MON_IP" \
    sudo --non-interactive --validate \
    || exit_status=$?
  trace_off
  if (( exit_status )); then
    common::err $(( ERR_STATUS_START + 4 )) "Failed to validate SSHing to the monitor IP ($MON_IP)"
  fi

  common::info "> Check hosts for OSDs"
  local -i idx
  local host
  for idx in "${!OSD_HOSTS[@]}"; do
    host="${OSD_HOSTS[idx]}"
    common::info ">> Check host '$host'"
    trace_on
    ssh "${SSH_COMM_OPTIONS[@]}" "$USER@$host" \
      sudo --non-interactive --validate \
      || exit_status=$?
    trace_off
    if (( exit_status )); then
      common::err $(( ERR_STATUS_START + 4 )) "Failed to validate SSHing to host '$host'"
    fi

    local -a devices
    parse_osd_devices devices "${OSD_DEVICES[idx]}"
    for device in "${devices[@]}"; do
      common::info ">>> Check device '$device'"
      trace_on
      ssh "${SSH_COMM_OPTIONS[@]}" "$USER@$host" \
        test -b "$device" \
        || exit_status=$?
      trace_off
      if (( exit_status )); then
        common::err $(( ERR_STATUS_START + 4 )) "Device '$device' does not exist on host '$host'!"
      fi
    done
  done
}
stage "Verify passwordless SSH to hosts, passwordless sudo via $USER, and the existence of devices on hosts..."
verify_parameters


reset_host_devices() {
  local -i idx
  for idx in "${!OSD_HOSTS[@]}"; do
    local -a devices
    parse_osd_devices devices "${OSD_DEVICES[idx]}"

    for device in "${devices[@]}"; do
      common::info "> Resetting device '$device' on host '${OSD_HOSTS[idx]}'"
      trace_on
      # require passwordless sudo configured for $USER
      # shellcheck disable=SC2087
      ssh "${SSH_COMM_OPTIONS[@]}" "$USER@${OSD_HOSTS[idx]}" \
        sudo sh <<EOF
          pvs \
          --noheadings \
          --readonly \
          --select "pv_name=$device" \
          --options vg_name \
            | xargs -I '{}' \
            vgremove --force --verbose {}
EOF
      trace_off
    done
  done
}

readonly CEPHADM="$SCRIPT_DIR"/parallel-cephadm
readonly DEFAULT_OUTPUT_DIR="$PWD"/cephadm_target/output
readonly CEPH_SHELL="$CEPHADM shell --keyring $DEFAULT_OUTPUT_DIR/ceph.client.admin.keyring"
readonly CEPH="$CEPH_SHELL -- ceph"

bootstrap_cluster() {
  trace_on
  mkdir -p "$DEFAULT_OUTPUT_DIR"
  $CEPHADM bootstrap \
    --mon-ip "$MON_IP" \
    --output-dir "$DEFAULT_OUTPUT_DIR" \
    --ssh-user "$USER" \
    --skip-dashboard \
    --allow-overwrite \
    --allow-fqdn-hostname \
    --orphan-initial-daemons \
    --skip-monitoring-stack
  trace_off

  common::info "> Set the default number of monitor daemons to 1"
  trace_on
  $CEPH orch apply mon 1
  trace_off
  common::info "> Set the default number of monitor daemons to 1"
  trace_on
  $CEPH orch apply mgr 1
  trace_off
}

show_status() {
  stage "Show Cluster Status"
  trace_on
  $CEPH --status
  trace_off
}

add_hosts() {
  local host
  for host in "${OSD_HOSTS[@]}"; do
    common::info "> Adding host '$host'"
    trace_on
    ssh-copy-id "${SSH_COMM_OPTIONS[@]}" \
      -f -i "$DEFAULT_OUTPUT_DIR"/ceph.pub \
      "$USER@$host"
    trace_off

    trace_on
    $CEPH orch host add "$host"
    trace_off
  done
}

add_host_devices_as_osds() {
  local -i idx
  for idx in "${!OSD_HOSTS[@]}"; do
    local -a devices
    parse_osd_devices devices "${OSD_DEVICES[idx]}"

    common::info "> Adding devices" "$(common::print_array devices)" "on host '${OSD_HOSTS[idx]}' as OSDs"
    trace_on
    $CEPH orch daemon add osd "${OSD_HOSTS[idx]}:${OSD_DEVICES[idx]}"
    trace_off
  done
}


ceph_deploy::deploy() {
  stage "Reset devices on hosts..."
  reset_host_devices

  stage "Bootstrap a new cluster..."
  bootstrap_cluster

  trap "trace_off; show_status" EXIT

  stage "Add hosts to the cluster..."
  add_hosts

  stage "Add OSDs to the cluster..."
  add_host_devices_as_osds
}

# When CMD_MODE is true, this script is called from command line.
# Otherwise, we assume this script is called by another script, and
# therefore can later perform the actual run by calling the run function.
if [[ "${CMD_MODE:-true}" == true ]]; then
  ceph_deploy::deploy
fi
