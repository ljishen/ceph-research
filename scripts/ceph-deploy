#!/usr/bin/env bash
#
# Require bash version >= 4.4

set -euo pipefail

stage() { printf "\\n\\n\\033[1;33m[STAGE] %s\\033[0m\\n" "$*"; }
info() { printf "\\033[1;32m[INFO] %s\\033[0m\\n" "$*"; }
err() {
  local -ir exit_status="$1"
  shift
  printf "\\033[1;31m[ERROR] %s\\033[0m\\n" "$*" >&2
  exit "$exit_status"
}

vergte() { printf '%s\n%s' "$1" "$2" | sort -rCV; }
if ! vergte "${BASH_VERSION%%[^0-9.]*}" "4.4"; then
  err 1 "Require bash version >= 4.4"
fi

# https://stackoverflow.com/a/51548669
shopt -s expand_aliases
alias trace_on="{ echo; set -x; } 2>/dev/null"
alias trace_off="{ set +x; } 2>/dev/null"
export PS4='# ${BASH_SOURCE:-"$0"}:${LINENO} - ${FUNCNAME[0]:+${FUNCNAME[0]}()} > '


usage() {
  cat <<EOF
Usage: $0 -m MON_IP -o <HOST_DEVICES> [-o <HOST_DEVICES> ...]
  -m : (\$MON_IP)             IP address for the clusterâ€™s first monitor daemon
  -o : (\$OSD_HOST_DEVICES)   Create OSDs on the storage devices of the host
                             HOST_DEVICES := host:device1[,device2,...]
  -h :                       Show this help text

All SSH connections to host clusters will use the user defined by '\$USER' (current: $USER).

EOF
}

OSD_HOST_DEVICES=()
while getopts ":m:o:h" option; do
  case $option in
    m ) MON_IP=$OPTARG ;;
    o ) OSD_HOST_DEVICES+=("$OPTARG") ;;
    h )
      usage
      exit
      ;;
    \? )
      usage
      err 2 "Invalid option: -$OPTARG"
      ;;
    :  )
      usage
      err 2 "Option -$OPTARG requires an argument."
      ;;
    *  )
      usage
      exit
  esac
done
shift "$(( OPTIND - 1 ))"

if [[ -z "${MON_IP:-}" ]]; then
  usage
  err 3 "Please specify the IP address of the first monitor using '-m'"
fi

if ! [[ "$MON_IP" =~ ^[[:digit:].]+$ ]]; then
  err 4 "Invalid IP address: $MON_IP"
fi

if (( "${#OSD_HOST_DEVICES[@]}" == 0 )); then
  usage
  err 3 "Please specify HOST_DEVICES for OSDs using '-o'"
fi

parse_osd_devices() {
  local -n device_arr=$1
  # shellcheck disable=SC2034
  IFS=',' read -ra device_arr <<< "$2"
}

index_of_arr() {
  local -nr arr=$1
  local -r lookfor="$2"
  local -i idx found_idx=-1
  for idx in "${!arr[@]}"; do
    if [[ "${arr[idx]}" == "$lookfor" ]]; then
      found_idx="$idx"
      break
    fi
  done
  echo "$found_idx"
}

OSD_HOSTS=()
OSD_DEVICES=()

populate_osd_host_devices() {
  local host_devices_str
  for host_devices_str in "${OSD_HOST_DEVICES[@]}"; do
    local -a host_devices_arr
    IFS=':' read -ra host_devices_arr <<< "$host_devices_str"
    if (( ${#host_devices_arr[@]} != 2 )); then
      err 4 "Invalid HOST_DEVICES (host:device1[,device2,...]) format: $host_devices_str"
    fi
    if [[ "${host_devices_arr[0]}" == *@* ]]; then
      err 4 "All SSH connections use the user defined by '\$USER' (current: $USER)"
    fi

    local -i index_of_hosts
    index_of_hosts=$(index_of_arr OSD_HOSTS "${host_devices_arr[0]}")

    # shellcheck disable=SC2034
    local -a devices prev_devices
    local -i index_of_devices
    parse_osd_devices devices "${host_devices_arr[1]}"
    for device in "${devices[@]}"; do
      if ! [[ "$device" =~ ^/dev/ ]]; then
        err 4 "Invalid device '$device' in '$host_devices_str'"
      fi

      if (( index_of_hosts >= 0 )); then
        parse_osd_devices prev_devices "${OSD_DEVICES[index_of_hosts]}"
        index_of_devices=$(index_of_arr prev_devices "$device")
        if (( index_of_devices >= 0 )); then
          err 4 "Duplicated device '$device' specified for host '${host_devices_arr[0]}'"
        fi
      fi
    done

    OSD_HOSTS+=("${host_devices_arr[0]}")
    OSD_DEVICES+=("${host_devices_arr[1]}")
  done
}
populate_osd_host_devices

readonly SSH_COMM_OPS=(
  -o "GlobalKnownHostsFile=/dev/null"
  -o "LogLevel=ERROR"
  -o "PasswordAuthentication=no"
  -o "StrictHostKeyChecking=no"
  -o "UserKnownHostsFile=/dev/null"
)

stage "Verify passwordless SSH to hosts, passwordless sudo for $USER, and devices on hosts..."
verify_parameters() {
  local -i exit_status=0

  info "> Check the host for the monitor"
  trace_on
  ssh "${SSH_COMM_OPS[@]}" "$USER@$MON_IP" \
    sudo --non-interactive --validate \
    || exit_status=$?
  trace_off
  if (( exit_status != 0 )); then
    err 5 "Failed to validate SSHing to the monitor IP ($MON_IP)"
  fi

  info "> Check hosts for OSDs"
  local -i idx
  local host
  for idx in "${!OSD_HOSTS[@]}"; do
    host="${OSD_HOSTS[idx]}"
    info ">> Check host '$host'"
    trace_on
    ssh "${SSH_COMM_OPS[@]}" "$USER@$host" \
      sudo --non-interactive --validate \
      || exit_status=$?
    trace_off
    if (( exit_status != 0 )); then
      err 5 "Failed to validate SSHing to host '$host'"
    fi

    local -a devices
    parse_osd_devices devices "${OSD_DEVICES[idx]}"
    for device in "${devices[@]}"; do
      info ">>> Check device '$device'"
      trace_on
      ssh "${SSH_COMM_OPS[@]}" "$USER@$host" \
        test -b "$device" \
        || exit_status=$?
      trace_off
      if (( exit_status != 0 )); then
        err 5 "Device '$device' does not exist on host '$host'!"
      fi
    done
  done
}
verify_parameters


stage "Reset devices on Hosts..."
reset_host_devices() {
  local -i idx
  for idx in "${!OSD_HOSTS[@]}"; do
    local -a devices
    parse_osd_devices devices "${OSD_DEVICES[idx]}"

    for device in "${devices[@]}"; do
      info "> Resetting device '$device' on host '${OSD_HOSTS[idx]}'"
      trace_on
      # require passwordless sudo configured for $USER
      # shellcheck disable=SC2087
      ssh "${SSH_COMM_OPS[@]}" "$USER@${OSD_HOSTS[idx]}" \
        sudo sh <<EOF
          pvs \
          --noheadings \
          --readonly \
          --select "pv_name=$device" \
          --options vg_name \
            | xargs -I '{}' \
            vgremove --force --verbose {}
EOF
      trace_off
    done
  done
}
reset_host_devices


readonly CEPHADM="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"/parallel-cephadm
readonly DEFAULT_OUTPUT_DIR="$PWD"/cephadm_target/output
readonly CEPH_SHELL="$CEPHADM shell --keyring $DEFAULT_OUTPUT_DIR/ceph.client.admin.keyring"
readonly CEPH="$CEPH_SHELL -- ceph"

mkdir -p "$DEFAULT_OUTPUT_DIR"

stage "Bootstrap A New Cluster..."
trace_on
$CEPHADM bootstrap \
  --mon-ip "$MON_IP" \
  --output-dir "$DEFAULT_OUTPUT_DIR" \
  --ssh-user "$USER" \
  --skip-dashboard \
  --allow-overwrite \
  --allow-fqdn-hostname \
  --orphan-initial-daemons \
  --skip-monitoring-stack
trace_off

info "> Set the default number of monitor daemons to 1"
trace_on
$CEPH orch apply mon 1
trace_off
info "> Set the default number of monitor daemons to 1"
trace_on
$CEPH orch apply mgr 1
trace_off

show_status() {
  stage "Show Cluster Status"
  trace_on
  $CEPH --status
  trace_off
}
trap "trace_off; show_status" EXIT


stage "Add Hosts to the Cluster..."
add_hosts() {
  local host
  for host in "${OSD_HOSTS[@]}"; do
    info "> Adding host '$host'"
    trace_on
    ssh-copy-id "${SSH_COMM_OPS[@]}" \
      -f -i "$DEFAULT_OUTPUT_DIR"/ceph.pub \
      "$USER@$host"
    trace_off

    trace_on
    $CEPH orch host add "$host"
    trace_off
  done
}
add_hosts


stage "Add OSDs to the Cluster..."
add_host_devices_as_osds() {
  local -i idx
  for idx in "${!OSD_HOSTS[@]}"; do
    local -a devices
    local joined
    parse_osd_devices devices "${OSD_DEVICES[idx]}"
    printf -v joined '%s, ' "${devices[@]@Q}"

    info "> Adding devices [${joined%, }] on host '${OSD_HOSTS[idx]}' as OSDs"
    trace_on
    $CEPH orch daemon add osd "${OSD_HOSTS[idx]}:${OSD_DEVICES[idx]}"
    trace_off
  done
}
add_host_devices_as_osds
