#!/usr/bin/env bash
#
# Require bash version >= 4.4
#
# This script depends on passwordless ssh and passwordless sudo via the current
# user ($USER) on remote hosts.

set -euo pipefail

readonly SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
# shellcheck source=./common.sh
. "$SCRIPT_DIR/common.sh"


usage() {
  cat <<EOF
Usage: $0 -m MON_IP -h OSD_HOST [-h OSD_HOST]... -s SCRIPT_FILE

Options:
  -m :         IP address for the clusterâ€™s monitor daemon.
  -h :         OSD host (e.g., -h host1 -h host2).
  -s :         the remote script (relative path to the remote_script/ceph_volume dir)
               for creating and querying ceph volumes on each host.

Defining the LVS_PROVISION=no can skip the logical volumes provisioning on hosts.

All SSH connections to the cluster hosts will use the user '\$USER' (current: $USER).

EOF
}

if (( $# < 2 )); then
  usage
  exit
fi


OSD_HOSTS=()
while getopts ":m:h:s:" option; do
  case $option in
    m  ) readonly MON_IP=$OPTARG ;;
    h  ) OSD_HOSTS+=("$OPTARG") ;;
    s  ) SCRIPT_FILE=$OPTARG ;;
    \? )
      usage
      common::err $(( ERR_STATUS_START + 1 )) "Invalid option: -$OPTARG"
      ;;
    :  )
      usage
      common::err $(( ERR_STATUS_START + 1 )) "Option -$OPTARG requires an argument."
      ;;
    *  )
      usage
      exit
  esac
done
shift "$(( OPTIND - 1 ))"

if [[ -z "${MON_IP:-}" ]]; then
  usage
  common::err $(( ERR_STATUS_START + 2 )) \
    "Please specify the IP address of the monitor using '-m'"
fi

if ! [[ "$MON_IP" =~ ^[[:digit:].]+$ ]]; then
  common::err $(( ERR_STATUS_START + 3 )) "Invalid IP address: $MON_IP"
fi

if (( "${#OSD_HOSTS[@]}" == 0 )); then
  usage
  common::err $(( ERR_STATUS_START + 2 )) "Please specify OSD_HOSTS using '-h'"
fi

if [[ -z "${SCRIPT_FILE:-}" ]]; then
  common::err $(( ERR_STATUS_START + 2 )) \
    "Please specify the SCRIPT_FILE using '-s'"
fi

if ! [[ -f "$SCRIPT_DIR/remote_script/ceph_volume/$SCRIPT_FILE" ]]; then
  common::err $(( ERR_STATUS_START + 3 )) \
    "Cannot find the script file '$SCRIPT_FILE' under the remote_script/ceph_volume dir"
fi

common::debug OSD_HOSTS: "$(common::print_array OSD_HOSTS)"


install_docker_sar() {
  common::stage "Check and install docker and sar..."

  local -ar all_hosts=( "$MON_IP" "${OSD_HOSTS[@]}" )
  local -a param_install_docker_hosts=() param_install_sar_hosts=()
  local host

  for host in "${all_hosts[@]}"; do
    if ! ssh "${SSH_COMM_OPTIONS[@]}" "$USER@$host" \
      command -v "docker" >/dev/null 2>&1; then
      param_install_docker_hosts+=( --host "$host" )
    fi

    if ! ssh "${SSH_COMM_OPTIONS[@]}" "$USER@$host" \
      command -v "sar" >/dev/null 2>&1; then
      param_install_sar_hosts+=( --host "$host" )
    fi
  done

  if (( ${#param_install_docker_hosts[@]} )); then
    "$SCRIPT_DIR"/parallel-docker-install \
      --env INFO_LEVEL=1 \
      "${param_install_docker_hosts[@]}"
  fi

  if (( ${#param_install_sar_hosts[@]} )); then
    CMD_MODE=false "$SCRIPT_DIR"/parallel-exec-script \
      --script=install/sysstat \
      --env INFO_LEVEL=1 \
      "${param_install_sar_hosts[@]}"
  fi
}
install_docker_sar

prepare_param_hosts() {
  local -n _param_hosts=$1
  local host

  for host in "${OSD_HOSTS[@]}"; do
    _param_hosts+=( --host "$host" )
  done
}

# shellcheck source=./remote_script/ceph_volume/interface.sh
. "$SCRIPT_DIR"/remote_script/ceph_volume/interface.sh
create_ceph_lvs() {
  common::stage "Create logical volumes on OSD hosts..."

  local -a param_hosts
  prepare_param_hosts param_hosts

  "$SCRIPT_DIR"/parallel-exec-script \
    --script ceph_volume/"$SCRIPT_FILE" \
    --env INFO_LEVEL=1 \
    --env CEPH_VOLUME_OPERATION="$CEPH_VOLUME_OPERATION_CREATE" \
    "${param_hosts[@]}"
}
if [[ "${LVS_PROVISION:-yes}" != "no" ]]; then
  create_ceph_lvs
fi


# shellcheck source=./remote_script/service/interface.sh
. "$SCRIPT_DIR"/remote_script/service/interface.sh
start_sys_activity_daemons() {
  common::stage "Launch system activity collector daemons on cluster hosts..."

  local -a param_hosts=( --host "$MON_IP" )
  prepare_param_hosts param_hosts

  "$SCRIPT_DIR"/parallel-exec-script \
    --script service/sar \
    --env INFO_LEVEL=1 \
    --env SERVICE_OPERATION="$SERVICE_OPERATION_RESTART" \
    "${param_hosts[@]}"
}

stop_sys_activity_daemons() {
  common::stage "Stop system activity collector daemons and gather results..."
  local -r sys_activity_data_dir="$OUTPUT_DIR"/sys_activity
  mkdir --parents "$sys_activity_data_dir"

  local -ar all_hosts=( "$MON_IP" "${OSD_HOSTS[@]}" )
  local host remote_output_file
  for host in "${all_hosts[@]}"; do
    INFO_LEVEL=1
    common::info "Backing up system activity information from $host"

    remote_output_file="$(
      "$SCRIPT_DIR"/parallel-exec-script \
        --script service/sar \
        --env INFO_LEVEL=1 \
        --env SERVICE_OPERATION="$SERVICE_OPERATION_QUERY" \
        --host "$host" | common::parse_remote_out
    )"

    "$SCRIPT_DIR"/parallel-exec-script \
      --script service/sar \
      --env INFO_LEVEL=1 \
      --env SERVICE_OPERATION="$SERVICE_OPERATION_STOP" \
      --host "$host"

    local local_output_file
    if [[ "$host" == "$MON_IP" ]]; then
      local_output_file=mon.$host.dat
    else
      local_output_file=osd.$host.dat
    fi

    scp -C "${SSH_COMM_OPTIONS[@]}" -p \
      "$host":"$remote_output_file" \
      "$sys_activity_data_dir/$local_output_file"
  done
}

deploy_ceph() {
  local -a param_host_osds
  local host host_lvs joined

  for host in "${OSD_HOSTS[@]}"; do
    host_lvs=("$(
      "$SCRIPT_DIR"/parallel-exec-script \
        --script ceph_volume/"$SCRIPT_FILE" \
        --env CEPH_VOLUME_OPERATION="$CEPH_VOLUME_OPERATION_QUERY" \
        --host "$host" | common::parse_remote_out
    )")

    printf -v joined '%s,' "${host_lvs[@]}"
    param_host_osds+=( -o "$host:${joined%,}" )
  done

  local ceph_deploy_output
  ceph_deploy_output="$(
    "$SCRIPT_DIR"/ceph-deploy -m "$MON_IP" "${param_host_osds[@]}" \
      2>&1 | tee /dev/tty
  )"

  CEPH_CLUSTER_FSID="$(
    grep --only-matching --perl-regexp "Cluster fsid: \K[[:alnum:]-]+" \
      <<< "$ceph_deploy_output"
  )"

  CEPH_CLUSTER_KEYRING_PATH="$(
      grep --only-matching --perl-regexp "Wrote keyring to \K.+" \
      <<< "$ceph_deploy_output"
  )"
}

tear_down_ceph() {
  if [[ -z "${CEPH_CLUSTER_FSID:-}" ]]; then
    common::err $(( ERR_STATUS_START + 4 )) \
      "Unable to read the cluster fsid."
  fi

  local -a param_hosts=( --host "$MON_IP" )
  prepare_param_hosts param_hosts

  INFO_LEVEL=1
  common::info "Tearing down the Ceph cluster (fsid: $CEPH_CLUSTER_FSID)"
  "$SCRIPT_DIR"/parallel-cephadm "${param_hosts[@]}" \
    rm-cluster \
    --force \
    --fsid "$CEPH_CLUSTER_FSID"
}

shell_cmd() {
  if [[ -z "${CEPH_CLUSTER_KEYRING_PATH}" ]]; then
    common::err $(( ERR_STATUS_START + 4 )) \
      "Fail to read the Ceph cluster's keyring file."
  fi

  echo "$SCRIPT_DIR/parallel-cephadm shell" \
    "--keyring $CEPH_CLUSTER_KEYRING_PATH" \
    "--"
}

get_suggested_pg_count() {
  # Logic behind PG Count
  # See https://ceph.com/pgcalc/
  #     https://ceph.com/pgcalc_assets/pgcalc.js (function updatePGCount)
  #     https://docs.ceph.com/en/latest/rados/operations/placement-groups/#choosing-number-of-placement-groups
  awk -v pool_size="$1" -v num_osds="$2" -v target_pgs_per_osd="${3:-100}" '
    function nearestpower2(num) {
      tmp = 2 ^ int(log(num) / log(2))
      if (tmp < num * (1 - 0.25))
        tmp *= 2
      return tmp
    }

    BEGIN {
      min_value = nearestpower2(int(num_osds / pool_size) + 1)
      if (min_value < num_osds)
        min_value *= 2

      calc_value = nearestpower2(int(target_pgs_per_osd * num_osds / pool_size))

      print (min_value > calc_value ? min_value : calc_value)
    }
  '
}


bench_replicated_pool() {
  local -r pool_name="bench_failure_management_resource_utilization"
  local -r data_size_per_osd=$(( 3 * 1024 * 1024 ))
  local -ar object_size_bytes_arr=(
    $(( 4 * 1024 ))
    $(( 32 * 1024 ))
    $(( 256 * 1024 ))
    $(( 2048 * 1024 ))
    $(( 16384 * 1024 ))
  )

  local -a pool_size_arr
  IFS=' ' read -ra pool_size_arr <<< "$(seq -s ' ' 1 "${#OSD_HOSTS[@]}")"

  local -i pool_size suggested_pg_count prev_suggested_pg_count=0
  for pool_size in "${pool_size_arr[@]}"; do
    suggested_pg_count=$(
      get_suggested_pg_count "$pool_size" ${#OSD_HOSTS[@]})
    if (( suggested_pg_count == prev_suggested_pg_count )); then
      continue
    fi
    prev_suggested_pg_count=$suggested_pg_count

    local -a num_pgs_arr=(
      $(( suggested_pg_count / 4 ))
      $(( suggested_pg_count / 2 ))
      suggested_pg_count
      $(( suggested_pg_count * 2 ))
      $(( suggested_pg_count * 4 ))
    )

    local -i num_pgs
    for num_pgs in "${num_pgs_arr[@]}"; do
      local -i object_size_bytes
      for object_size_bytes in "${object_size_bytes_arr[@]}"; do
        deploy_ceph

        common::stage "Prepare data on the cluster..."

        INFO_LEVEL=1
        common::info "Set pool attributes"
        trace_on
        $(shell_cmd) ceph osd pool create "$pool_name" "$num_pgs" "$num_pgs" replicated
        $(shell_cmd) ceph osd pool set "$pool_name" pg_autoscale_mode off
        $(shell_cmd) ceph osd pool set "$pool_name" size "$pool_size"
        $(shell_cmd) ceph osd pool set "$pool_name" min_size 1
        $(shell_cmd) ceph osd pool set "$pool_name" noscrub 1
        $(shell_cmd) ceph osd pool set "$pool_name" nodeep-scrub 1
        trace_off

        $(shell_cmd) ceph osd pool ls detail

        common::info "Loading objects"
        # -b op_size
        # -O object_size
        #   https://github.com/ceph/ceph/blob/v16.0.0/src/tools/rados/rados.cc#L183
        trace_on
        $(shell_cmd) rados bench 99999999 write \
          --pool "$pool_name" \
          -b $(( object_size_bytes )) \
          -O $(( object_size_bytes )) \
          --max-objects $(( data_size_per_osd * ${#OSD_HOSTS[@]} / object_size_bytes )) \
          --concurrent-ios $(( ${#OSD_HOSTS[@]} * 16 )) \
          --show-time \
          --write-object \
          --write-omap \
          --write-xattr \
          --no-cleanup
        trace_off

        # take down OSDs

        tear_down_ceph

        sleep 10
      done
    done
  done
}

bench_erasure_coded_pool() {
  common::err $(( ERR_STATUS_START + 999 )) \
    "Function not implemented yet!"
}


OUTPUT_DIR="$PWD/results"
main() {
  start_sys_activity_daemons
  bench_replicated_pool
  stop_sys_activity_daemons
}
main
