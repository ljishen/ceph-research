#!/usr/bin/env bash

set -euo pipefail

err() {
  local -ir exit_status="$1"
  shift
  printf "\\033[1;31m[ERROR] %s\\033[0m\\n" "$*" >&2
  exit "$exit_status"
}

# https://stackoverflow.com/a/51548669
shopt -s expand_aliases
alias trace_on="{ echo; set -x; } 2>/dev/null"
alias trace_off="{ set +x; } 2>/dev/null"
export PS4='# ${BASH_SOURCE:-"$0"}:${LINENO} - ${FUNCNAME[0]:+${FUNCNAME[0]}()} > '


usage() {
  cat <<EOF
Usage: $0 OPTIONS

Options:
  -h HOST_FILE, --hosts=HOST_FILE
                        hosts file (each line "[user@]host[:port]")
  -H HOST_STRING, --host=HOST_STRING
                        additional host entries ("[user@]host[:port]")
EOF
}

if (( $# == 0 )); then
  usage
  exit
fi


HOST_PARAMS=()
# loop positional params: https://unix.stackexchange.com/a/314041
for (( idx = 1; idx <= $#; idx++ )); do
  if [[ "${!idx}" == @(-h|-H|--hosts|--host) ]]; then
    HOST_PARAMS+=("${!idx}")
    (( idx++ ))
    if [[ -z "${!idx:-}" ]]; then
      usage
      exit 2
    fi
    HOST_PARAMS+=("${!idx}")
    continue
  fi

  if [[ "${!idx}" =~ ^(--hosts=|--host=) ]]; then
    HOST_PARAMS+=("${!idx}")
    continue
  fi

  _err 1 "Unsupport parameter '${!idx}'"
done

if ! command -v "parallel-ssh" >/dev/null 2>&1; then
  _err 2 "Please install parallel-ssh"
fi

# max number of parallel threads
: "${PAR:=5}"

trace_on
parallel-ssh \
  -O StrictHostKeyChecking=no \
  -O UserKnownHostsFile=/dev/null \
  -O GlobalKnownHostsFile=/dev/null \
  -O LogLevel=ERROR \
  --par="$PAR" \
  --inline \
  --send-input \
  --print \
  "${HOST_PARAMS[@]}" \
  bash <<'EOF'
_info() { printf "\\033[1;32m[INFO] %s\\033[0m\\n" "$*"; }
_err() {
  local -ir exit_status="$1"
  shift
  printf "\\033[1;31m[ERROR] %s\\033[0m\\n" "$*" >&2
  exit "$exit_status"
}

get_distro() {
  local distro
  distro="$(head -n1 /etc/issue | awk '{ print tolower($1) }')"
  if [[ "$distro" != @(ubuntu|debian) ]]; then
    _err 1 "Only support Ubuntu and Debian platforms"
  fi
  echo "$distro"
}
SYS_DISTRO="$(get_distro)"

get_arch() {
  local machine_name arch
  machine_name="$(uname -m)"
  if [[ "$machine_name" == "aarch64" ]]; then
    arch=arm64
  elif [[ "$machine_name" == "armv7l" ]]; then
    arch=armhf
  elif [[ "$machine_name" == "x86_64" ]]; then
    arch=amd64
  else
    _err 1 "Docker does not support architecture '$machine_name'"
  fi
  echo "$arch"
}
SYS_ARCH="$(get_arch)"


_info "Uninstall old versions..."
sudo apt-get purge docker docker-engine docker.io containerd runc >/dev/null

_info "Set up Docker's repositories..."
sudo apt-get update >/dev/null
sudo apt-get install -y \
  apt-transport-https \
  ca-certificates \
  curl \
  gnupg-agent \
  software-properties-common >/dev/null

# Circumvent the "Warning: apt-key output should not be parsed (stdout is not a terminal)"
#   https://stackoverflow.com/a/49462622
curl -fsSL https://download.docker.com/linux/"$SYS_DISTRO"/gpg \
  | sudo APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=1 apt-key add - >/dev/null

sudo add-apt-repository \
  "deb [arch=$SYS_ARCH] https://download.docker.com/linux/$SYS_DISTRO \
  $(lsb_release -cs) \
  stable" >/dev/null

_info "Install docker engine..."
sudo apt-get update >/dev/null
sudo apt-get install docker-ce docker-ce-cli containerd.io >/dev/null

_info "Add your user to the docker group..."
sudo usermod -aG docker $USER

if [[ -d "$HOME/.docker" ]]; then
  _info "Fix possible permission error"
  sudo chown "$(id --user --name)":"$(id --group --name)" "$HOME/.docker" -R
  sudo chmod g+rwx "$HOME/.docker" -R
fi

_info "Done!"

# executing this command will replace the current shell and
# lose our defined functions. So I put it at the end.
newgrp docker
EOF
trace_off
